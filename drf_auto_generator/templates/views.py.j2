# Generated by drf-auto-generator.
# Defines ViewSets for handling API requests.

from rest_framework import viewsets
from rest_framework import permissions # For defining access permissions
from rest_framework import pagination # For controlling pagination
from rest_framework import filters # For ordering and searching

# --- Import models ---
from .models import (
{%- for table in tables %}
    {{ table.model_name }}, {# Indent this line within the template #}
{%- endfor %}
)

# --- Import serializers ---
from .serializers import (
{%- for table in tables %}
    {{ table.model_name }}Serializer, {# Indent this line within the template #}
{%- endfor %}
)

# --- Default Settings (Consider making these configurable via generation options) ---

# Example Custom Pagination Class (if needed, otherwise rely on defaults in settings.py)
# class StandardResultsSetPagination(pagination.PageNumberPagination):
#    page_size = 25
#    page_size_query_param = 'page_size'
#    max_page_size = 1000

# --- ViewSet Definitions ---
{% for table in tables %}

class {{ table.model_name }}ViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows {{ p.plural(table.model_name) if p.plural(table.model_name) else table.model_name + "s" }} to be viewed or edited.

    Provides standard CRUD operations.
    """
    # --- Core ViewSet Attributes ---
    queryset = {{ table.model_name }}.objects.all().order_by('{{ (table.fields|selectattr('is_pk', 'equalto', True)|first).name }}') # Default ordering by PK
    serializer_class = {{ table.model_name }}Serializer

    # --- API Feature Configuration ---

    # Permissions: Who can access this view?
    # Defaulting to IsAuthenticatedOrReadOnly is often a safe start.
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    # Other options:
    # permission_classes = [permissions.AllowAny] # Allows anyone access (use carefully)
    # permission_classes = [permissions.IsAuthenticated] # Requires user to be logged in
    # permission_classes = [permissions.IsAdminUser] # Requires user to be admin/superuser

    # Pagination: How are large result sets handled?
    # Uses DEFAULT_PAGINATION_CLASS from settings.py by default.
    # pagination_class = StandardResultsSetPagination # Uncomment to use custom pagination

    # Filtering Backends: Enable Ordering, Searching, etc.
    # Requires corresponding configuration (ordering_fields, search_fields)
    filter_backends = [
        filters.OrderingFilter,
        filters.SearchFilter,
        # Add 'django_filters.rest_framework.DjangoFilterBackend' if using django-filter
    ]

    # Ordering Fields: Which fields can the client order results by?
    # '__all__' allows ordering by any model field (potential performance impact).
    ordering_fields = '__all__'
    # OR explicitly list allowed fields:
    # ordering_fields = ['{{ (table.fields|selectattr('is_pk', 'equalto', True)|first).name }}', 'name', 'created_at'] # Example

    # Search Fields: Which fields should be searched when using the 'search' query parameter?
    # Use '^' for startswith, '=' for exact match, '@' for full-text search (backend dependent), '$' for regex.
    search_fields = [
        {%- set search_count = namespace(value=0) -%}
        {%- for field in table.fields if field.type in ['CharField', 'TextField', 'EmailField'] -%}
            {%- if search_count.value < 5 %} # Limit initial search fields
            '{{ field.name }}',
            {%- set search_count.value = search_count.value + 1 -%}
            {%- endif -%}
        {%- endfor -%}
        # Add related fields if needed: 'related_model__field_name'
    ]

    # Django-filter Integration (Optional - requires 'django-filter' package)
    # filterset_fields = { # Define specific fields and lookup types for filtering
    #    'field1': ['exact', 'icontains'],
    #    'date_field': ['year', 'month', 'day', 'gte', 'lte'],
    #    'related_model_field': ['exact'],
    # }
    # Or use filterset_class = YourFilterSet # For more complex filters

    # --- Method Overrides (Optional) ---
    # def get_queryset(self): ... # For more complex queryset filtering (e.g., based on user)
    # def perform_create(self, serializer): ... # To add extra data on create (e.g., owner=self.request.user)
    # def perform_update(self, serializer): ...
    # def perform_destroy(self, instance): ...

    # TODO: Handle nested routing if config.relation_style == 'nested'
    # This typically involves overriding get_queryset to filter based on URL kwargs.

{% endfor %}
