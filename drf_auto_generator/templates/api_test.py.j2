{# File: drf_auto_generator/templates/api_test.py.j2 #}
# Generated by drf-auto-generator - Integration tests for {{ model_name }} API using Django's APITestCase.

import uuid
import time # For generating unique suffixes
from datetime import date, datetime, timezone
from decimal import Decimal # Import Decimal if needed for number fields
from typing import Optional

# Use Django's testing framework
from django.urls import reverse
from django.contrib.auth import get_user_model
from rest_framework import status
from rest_framework.test import APITestCase

# Import the model being tested and any related models needed for setup
from {{ app_name }}.models import {{ model_name }}{% for related_model in related_models_needed %}, {{ related_model }}{% endfor %}

# Import Faker for data generation within tests
from faker import Faker

# Initialize Faker
fake = Faker()

# Get the User model
User = get_user_model()

# Get the model name, table name, and app name
model_name = '{{ model_name }}'
table_name = '{{ table_name }}'
app_name = '{{ app_name }}'

# Payload fields
create_payload_fields = {{ create_payload_fields|safe }}
patch_payload_fields = {{ patch_payload_fields|safe }}
invalid_payload_fields = {{ invalid_payload_fields|safe }}

class {{ model_name }}APITests(APITestCase):
    """
    Tests for CRUD operations on the {{ model_name }} model via the API.
    Uses Django's APITestCase and test client.
    """
    @classmethod
    def setUpTestData(cls):
        """
        Set up non-modified objects used by all test methods.
        Creates a test user and attempts to create required related model instances using Django ORM.
        """
        # Use a unique username for test user per model test class to avoid potential clashes
        # if tests run without full DB teardown between classes (though less common with APITestCase)
        cls.test_username = 'testuser_{{ model_name|lower }}'
        cls.test_password = 'testpassword' # Keep password simple for tests
        cls.user = User.objects.create_user(username=cls.test_username, password=cls.test_password)
        print("INFO (setUpTestData): Created test user '{}'.".format(cls.test_username))

        # Set up storage for related instances created here
        {% for related_model in related_models_needed %}
        cls.related_{{ related_model|lower }}s = []
        {% endfor %}

        # Create related model instances needed for ForeignKeys
        {% for related_model, fields_to_create in related_models_to_create.items() %}
        # Create 1 instance of {{ related_model }} for FK relations (can adjust count if needed)
        if {{ 'True' if fields_to_create is not none else 'False' }}: # Check if setup data is available
            try:
                instance_data = {
                    {%- for field, fake_value in fields_to_create.items() %}
                    '{{ field }}': {{ fake_value|safe }}{% if not loop.last %},{% endif %}
                    {%- endfor %}
                }
                # Ensure required fields actually got generated values
                if instance_data or not {{ 'True' if fields_to_create else 'False' }}: # Attempt create even if no specific required fields found (e.g., only defaults or nullable fields)
                    instance = {{ related_model }}.objects.create(**instance_data)
                    # Use getattr to safely access the list attribute on cls
                    getattr(cls, 'related_{{ related_model|lower }}s', []).append(instance)
                    print("INFO (setUpTestData): Created related {{ related_model }} with PK {}.".format(instance.pk))
                else:
                    # This indicates a potential issue in the generator's data creation logic for related models
                    print("WARNING (setUpTestData): Could not generate required fields payload for related model {{ related_model }}.")
            except Exception as e:
                 # Catch errors during instance_data creation or object creation attempt
                 print("WARNING (setUpTestData): Could not create related instance of {{ related_model }}: {}".format(e))
                 # Test methods using this related object will likely need to be skipped
        else:
             # This means the generator couldn't find the related model's definition or fields
             print("WARNING (setUpTestData): Setup data for related model {{ related_model }} not found or generation failed.")
        {% endfor %}


    def setUp(self):
        """
        Set up for each test method. Authenticates the client.
        Creates a fresh instance of the primary model {{ model_name }} for modification tests, if possible.
        """
        # Authenticate the test client for this test method
        self.client.force_authenticate(user=self.user)
        self.test_instance = None
        self.test_instance_pk = None

        # --- Create a primary instance for tests that modify/delete ---
        {% if create_payload_fields %}
        try:
            create_data = {}
            valid_payload_possible = True
            {% for field_name, field_details in create_payload_fields.items() %}
            {# Check if this field represents a Foreign Key #}
            {% if field_details.is_fk %}
            related_list_name = 'related_{{ field_details.related_model|lower }}s'
            # Check if the required related object(s) were successfully created in setUpTestData
            if hasattr(self, related_list_name) and getattr(self, related_list_name):
                # Assign the PK of the first related object found
                create_data['{{ field_name }}'] = getattr(self, related_list_name)[0].pk
            else:
                # Check if this FK is required (not nullable)
                is_fk_required = {{ not field_details.options.get('null', True) }}
                if is_fk_required:
                    print("WARNING (setUp): Skipping {{ model_name }} instance creation: Required related '{{ field_details.related_model }}' for '{{ field_name }}' not available from setUpTestData.")
                    valid_payload_possible = False # Cannot create instance without required FK
                else:
                    # If FK is nullable, simply omit it from the creation data
                    print("INFO (setUp): Omitting nullable FK field '{{ field_name }}' for {{ model_name }} as related object not available.")
            {% else %}
            # Assign non-FK field using its pre-generated fake value (already repr'd)
            create_data['{{ field_name }}'] = {{ field_details.fake_value|safe }}
            {% endif %}
            {% endfor %}

            # Only attempt final creation if all required FKs were resolved
            if valid_payload_possible and create_data:
                # Filter out any potential None values if they aren't allowed by the field
                final_create_data = {k: v for k, v in create_data.items() if v is not None}
                required_ok = True
                # Final check for any other missing non-nullable fields (basic check)
                {% for field_name, field_details in create_payload_fields.items() %}
                {% if not field_details.options.get('null', True) and not field_details.options.get('blank', True) %}
                if '{{ field_name }}' not in final_create_data:
                    # Check if it was omitted because it was a required FK that failed setup
                    if not ({{ field_details.is_fk }} and not (hasattr(self, 'related_{{ field_details.related_model|lower }}s') and getattr(self, 'related_{{ field_details.related_model|lower }}s'))):
                        print("WARNING (setUp): Final payload missing required field '{{ field_name }}' for {{ model_name }}.")
                        required_ok = False
                {% endif %}
                {% endfor %}

                # Proceed only if required fields seem present and payload is not empty
                if required_ok and final_create_data:
                    self.test_instance = {{ model_name }}.objects.create(**final_create_data)
                    self.test_instance_pk = self.test_instance.pk
                    print("INFO (setUp): Created self.test_instance for {{ model_name }} with PK {}.".format(self.test_instance_pk))
                else:
                    if not required_ok:
                        print("WARNING (setUp): Could not create {{ model_name }} due to missing required fields in final payload.")
                    elif not final_create_data:
                        print("WARNING (setUp): Could not create {{ model_name }} because final payload was empty.")
                    self.test_instance = None
                    self.test_instance_pk = None
            else:
                if not valid_payload_possible:
                    print("INFO (setUp): Did not attempt {{ model_name }} creation because required FKs were missing.")
                else:
                    print("INFO (setUp): Did not attempt {{ model_name }} creation because initial create_data was empty.")
                self.test_instance = None
                self.test_instance_pk = None

        except Exception as e:
            # Use standard string formatting for exception message
            print("WARNING (setUp): Failed to create self.test_instance for {{ model_name }}. Error: {}".format(e))
            self.test_instance = None
            self.test_instance_pk = None
        {% else %}
        # Cannot generate payload automatically
        print("INFO (setUp): Skipping creation of self.test_instance for {{ model_name }}: No payload fields generated.")
        {% endif %}


    def _generate_valid_payload(self, unique_suffix_override: Optional[str] = None, **kwargs) -> dict:
        """
        Helper to generate a valid payload dictionary, allowing overrides.
        Uses related objects created in setUpTestData.
        Adds a unique suffix for fields needing it if unique_suffix_override is provided.
        """
        payload = {}
        {% for field_name, field_details in create_payload_fields.items() %}
        # Check explicit kwargs override first
        if {{ field_name|tojson }} in kwargs:
            payload['{{ field_name }}'] = kwargs['{{ field_name }}']

        {% if field_details.is_fk %}
        # Use the first related instance created in class setup if available
        related_list_name = 'related_{{ field_details.related_model|lower }}s'
        if hasattr(self.__class__, related_list_name) and getattr(self.__class__, related_list_name): # Check on class for setUpTestData
            payload['{{ field_name }}'] = getattr(self.__class__, related_list_name)[0].pk
        else:
            # Omit FK if related instance doesn't exist (API call might fail if required)
            pass
        {% else %}
        # Generate value, potentially making it unique if requested
        # Use the pre-generated repr string for uniqueness logic if needed
        fake_value_repr = {{ field_details.unique_fake_value|safe|tojson if field_details.needs_unique_value else field_details.fake_value|safe|tojson }}
        is_unique_needed = {{ 'True' if field_details.needs_unique_value else 'False' }}

        if unique_suffix_override and is_unique_needed:
            try:
                # Attempt to get base value by evaluating the standard fake value repr
                base_value = eval({{ field_details.fake_value|safe|tojson }})
                if isinstance(base_value, str):
                    unique_val = f"{base_value}_{unique_suffix_override}"
                    # Truncate if necessary based on model field options
                    max_len = {{ field_details.options.get('max_length')|default('None') }}
                    if max_len is not None:
                        unique_val = unique_val[:max_len]
                    payload['{{ field_name }}'] = unique_val
                elif isinstance(base_value, (int, float, Decimal)):
                    # For numbers, simple addition might work for uniqueness in tests, but could overflow
                    payload['{{ field_name }}'] = base_value + int(unique_suffix_override)
                else: # Fallback for other types, use unique repr directly
                    payload['{{ field_name }}'] = eval({{ field_details.unique_fake_value|safe }})
            except Exception as e_eval_unique:
                print("WARNING (_generate_valid_payload): Failed to eval unique value for {}, using fallback. Error: {}".format('{{ field_name }}', e_eval_unique))
                # Fallback: append suffix to string representation
                payload['{{ field_name }}'] = f"{fake_value_repr.strip('\'\"')}_{unique_suffix_override}"
        else:
            # Use standard fake value (non-unique needed or no suffix provided)
            try:
                payload['{{ field_name }}'] = eval({{ field_details.fake_value|safe }})
            except Exception as e_eval:
                print("WARNING (_generate_valid_payload): Failed to eval standard value for {}, using fallback. Error: {}".format('{{ field_name }}', e_eval))
                payload['{{ field_name }}'] = "{{ field_details.fake_value|safe }}".strip("'\"") # Fallback to plain string
        {% endif %}
        {% endfor %}

        payload.update(kwargs) # Apply any explicit overrides passed via **kwargs
        # Filter out None values before returning (API might reject null if not allowed)
        return {k: v for k, v in payload.items() if v is not None}

    # --- Test List Endpoint ---
    def test_list_{{ table_name }}(self):
        """GET /api/{{ table_name }}/ - Verify list endpoint returns 200 and results."""
        list_url = reverse('{{ app_name }}:{{ table_name }}-list')
        response = self.client.get(list_url)
        # Use assertEqual with msg for better failure info
        self.assertEqual(
            response.status_code, status.HTTP_200_OK,
            "List request failed with status {}. Response: {}".format(response.status_code, getattr(response, 'data', 'N/A'))
        )
        self.assertIn('results', response.data)
        self.assertIn('count', response.data)
        if self.test_instance_pk:
             found = any(item.get('{{ pk_field_name }}') == self.test_instance_pk for item in response.data.get('results', []))
             self.assertTrue(found, "Instance {} created in setUp not found in list response.".format(self.test_instance_pk))

    # --- Test Create Endpoint ---
    {% if create_payload_fields %}
    def test_create_{{ table_name }}(self):
        """POST /api/{{ table_name }}/ - Verify creation with valid data returns 201."""
        list_url = reverse('{{ app_name }}:{{ table_name }}-list')
        unique_suffix = str(int(time.time() * 1000))[-5:]
        payload = self._generate_valid_payload(unique_suffix_override=unique_suffix)

        if not payload:
            self.skipTest(f"Cannot generate valid payload for creating {model_name}.")

        # Check if required related objects were available for payload generation
        {% for field_name, field_details in create_payload_fields.items() %}
        {% if field_details.is_fk and not field_details.options.get('null', True) %}
        if '{{ field_name }}' not in payload:
            self.skipTest("Skipping create test: Setup failed for required related object '{}'.".format('{{ field_details.related_model }}'))
        {% endif %}
        {% endfor %}

        response = self.client.post(list_url, payload, format='json')
        self.assertEqual(
            response.status_code, status.HTTP_201_CREATED,
            "Create failed with status {}. Payload: {}. Response: {}".format(response.status_code, payload, response.data)
        )
        self.assertIn('{{ pk_field_name }}', response.data)
        created_pk = response.data['{{ pk_field_name }}']
        self.assertTrue({{ model_name }}.objects.filter({{ pk_field_name }}=created_pk).exists(),
                        "Created object not found in database.")
    {% else %}
    def test_create_{{ table_name }}(self):
        self.skipTest("Cannot auto-generate creation payload for {}.".format('{{ model_name }}'))
    {% endif %}

    # --- Test Retrieve Endpoint ---
    def test_retrieve_{{ table_name }}(self):
        """GET /api/{{ table_name }}/{pk}/ - Verify retrieve endpoint returns 200 for existing object."""
        if not self.test_instance_pk:
            self.skipTest("Skipping retrieve test for {}: test_instance not created in setUp.".format('{{ model_name }}'))
        detail_url = reverse('{{ app_name }}:{{ table_name }}-detail', kwargs={'pk': self.test_instance_pk})
        response = self.client.get(detail_url)
        self.assertEqual(
            response.status_code, status.HTTP_200_OK,
            "Retrieve failed with status {}. Response: {}".format(response.status_code, getattr(response, 'data', 'N/A'))
        )
        self.assertEqual(response.data.get('{{ pk_field_name }}'), self.test_instance_pk)

    def test_retrieve_{{ table_name }}_not_found(self):
        """GET /api/{{ table_name }}/{pk}/ - Verify retrieve returns 404 for non-existent PK."""
        non_existent_pk = 999999999
        try:
            detail_url = reverse('{{ app_name }}:{{ table_name }}-detail', kwargs={'pk': non_existent_pk})
            response = self.client.get(detail_url)
            self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        except Exception as e:
             self.fail("Retrieve 404 test failed unexpectedly (possibly URL pattern issue): {}".format(e))

    # --- Test Update Endpoint ---
    {% if create_payload_fields %}
    def test_update_{{ table_name }}(self):
        """PUT /api/{{ table_name }}/{pk}/ - Verify full update returns 200."""
        if not self.test_instance_pk:
            self.skipTest("Skipping update test for {}: test_instance not created.".format('{{ model_name }}'))

        detail_url = reverse('{{ app_name }}:{{ table_name }}-detail', kwargs={'pk': self.test_instance_pk})
        unique_suffix = str(int(time.time() * 1000))[-5:]
        payload = self._generate_valid_payload(unique_suffix_override=unique_suffix)
        field_to_check = next((field for field, details in create_payload_fields.items() if not details.is_fk), None)

        if not payload or not field_to_check:
             self.skipTest("Cannot generate valid payload or find field to check for updating {}.".format('{{ model_name }}'))

        # Ensure required FKs are in the PUT payload
        {% for field_name, field_details in create_payload_fields.items() %}
        {% if field_details.is_fk and not field_details.options.get('null', True) %}
        if '{{ field_name }}' not in payload:
            self.skipTest("Skipping update test: Cannot generate payload with required FK '{{ field_name }}'.")
        {% endif %}
        {% endfor %}

        response = self.client.put(detail_url, payload, format='json')
        self.assertEqual(
            response.status_code, status.HTTP_200_OK,
            "PUT failed with status {}. Payload: {}. Response: {}".format(response.status_code, payload, response.data)
        )
        self.assertEqual(response.data.get(field_to_check), payload.get(field_to_check))
        self.assertEqual(response.data.get('{{ pk_field_name }}'), self.test_instance_pk)
    {% else %}
    def test_update_{{ table_name }}(self):
        self.skipTest("Cannot auto-generate update payload for {}.".format('{{ model_name }}'))
    {% endif %}

    # --- Test Partial Update Endpoint ---
    {% if patch_payload_fields %}
    def test_partial_update_{{ table_name }}(self):
        """PATCH /api/{{ table_name }}/{pk}/ - Verify partial update returns 200."""
        if not self.test_instance_pk:
            self.skipTest("Skipping patch test for {}: test_instance not created.".format('{{ model_name }}'))
        patch_candidates = {{ patch_payload_fields|safe }} # Get list of possible fields
        if not patch_candidates:
            self.skipTest("Skipping patch test for {}: No patchable fields identified.".format('{{ model_name }}'))

        detail_url = reverse('{{ app_name }}:{{ table_name }}-detail', kwargs={'pk': self.test_instance_pk})
        # Select the first candidate field for simplicity
        field_to_patch_details = patch_candidates[0]
        patch_field_key = field_to_patch_details['key']
        # Generate a potentially unique value if needed, otherwise use standard fake value
        patch_value_repr = field_to_patch_details['unique_fake_value'] if field_to_patch_details['needs_unique_value'] else field_to_patch_details['fake_value']
        try:
            patch_value = eval(patch_value_repr)
        except Exception:
            patch_value = patch_value_repr.strip("'\"") # Fallback
        payload = { patch_field_key: patch_value }

        response = self.client.patch(detail_url, payload, format='json')
        self.assertEqual(
            response.status_code, status.HTTP_200_OK,
            "PATCH failed with status {}. Payload: {}. Response: {}".format(response.status_code, payload, response.data)
        )
        self.assertEqual(response.data.get(patch_field_key), patch_value)
    {% else %}
    def test_partial_update_{{ table_name }}(self):
        self.skipTest("Cannot auto-generate partial update payload for {}.".format('{{ model_name }}'))
    {% endif %}

    # --- Test Delete Endpoint ---
    def test_delete_{{ table_name }}(self):
        """DELETE /api/{{ table_name }}/{pk}/ - Verify delete returns 204 and object is gone."""
        pk_to_delete = None
        instance_to_delete = None
        {% if create_payload_fields %}
        try:
             unique_suffix = str(int(time.time() * 1000))[-5:]
             delete_payload = self._generate_valid_payload(unique_suffix_override=unique_suffix)
             if not delete_payload:
                self.skipTest("Cannot gen payload for delete setup.")
             # Check required FKs
             required_fks_ok = True
             {% for field_name, field_details in create_payload_fields.items() %}
             {% if field_details.is_fk and not field_details.options.get('null', True) %}
             if '{{ field_name }}' not in delete_payload:
                required_fks_ok = False
             {% endif %}
             {% endfor %}
             if required_fks_ok:
                instance_to_delete = {{ model_name }}.objects.create(**delete_payload)
                pk_to_delete = instance_to_delete.pk
             else:
                self.skipTest("Cannot create instance for delete: missing required FKs.")
        except Exception as e:
            self.fail("Failed to create instance for delete test: {}".format(e))
        {% else %}
        self.skipTest("Cannot auto-generate payload for delete test setup.")
        {% endif %}

        if pk_to_delete:
            detail_url = reverse('{{ app_name }}:{{ table_name }}-detail', kwargs={'pk': pk_to_delete})
            delete_response = self.client.delete(detail_url)
            self.assertEqual(delete_response.status_code, status.HTTP_204_NO_CONTENT)
            # Verify retrieve now returns 404
            get_response = self.client.get(detail_url)
            self.assertEqual(get_response.status_code, status.HTTP_404_NOT_FOUND)
        elif instance_to_delete is None:
             # If we skipped creation, we can't proceed
             pass # Or self.skipTest("Delete test skipped because setup instance creation failed.")

    # --- Test Validation/Constraint Errors ---
    {% if invalid_payload_fields %}
    def test_create_{{ table_name }}_invalid_data(self):
        """POST /api/{{ table_name }}/ - Verify creation with invalid data returns 400."""
        list_url = reverse('{{ app_name }}:{{ table_name }}-list')
        invalid_payload_base = {
            {%- for field_name, value in invalid_payload_fields.items() %}
            '{{ field_name }}': {{ value|safe }}{% if not loop.last %},{% endif %}
            {%- endfor %}
        }
        # Add required fields using valid data
        valid_required_payload = self._generate_valid_payload()
        final_invalid_payload = invalid_payload_base.copy()
        required_fks_available = True
        for req_field, req_value in valid_required_payload.items():
             field_details = create_payload_fields.get(req_field)
             is_required = field_details and not field_details['options'].get('null', True)
             if is_required and req_field not in final_invalid_payload:
                if field_details['is_fk'] and req_value is None: # Check if required FK value is missing
                    required_fks_available = False
                    print("INFO: Skipping invalid data test: Required FK '{}' missing from valid payload part.".format(req_field))
                    break
                final_invalid_payload[req_field] = req_value

        if not required_fks_available:
            self.skipTest("Cannot run invalid data test due to missing required FK setup.")
        if not final_invalid_payload:
            self.skipTest("Could not generate invalid payload for {}.".format('{{ model_name }}'))

        response = self.client.post(list_url, final_invalid_payload, format='json')
        self.assertEqual(
            response.status_code, status.HTTP_400_BAD_REQUEST,
            "Create with invalid data did not return 400. Payload: {}. Response: {}".format(final_invalid_payload, getattr(response, 'data', 'N/A'))
        )
        reported_errors = response.data.keys()
        invalid_keys_sent = invalid_payload_fields.keys()
        self.assertTrue(any(key in reported_errors for key in invalid_keys_sent),
                        "Expected validation error for one of {}, but errors were on: {}".format(
                            list(invalid_keys_sent), list(reported_errors)))
    {% endif %}

    # --- Test Unauthenticated Access ---
    def test_list_{{ table_name }}_unauthenticated(self):
        """GET /api/{{ table_name }}/ - Verify read-only access works without auth (if IsAuthenticatedOrReadOnly)."""
        list_url = reverse('{{ app_name }}:{{ table_name }}-list')
        self.client.logout() # Log out test client
        response = self.client.get(list_url)
        # Assumes default IsAuthenticatedOrReadOnly
        self.assertEqual(response.status_code, status.HTTP_200_OK, "Unauthenticated GET list failed")

    {% if create_payload_fields %}
    def test_create_{{ table_name }}_unauthenticated(self):
        """POST /api/{{ table_name }}/ - Verify create fails without auth (expect 401/403)."""
        list_url = reverse('{{ app_name }}:{{ table_name }}-list')
        unique_suffix = str(int(time.time() * 1000))[-5:]
        payload = self._generate_valid_payload(unique_suffix_override=unique_suffix)
        if not payload:
            self.skipTest("Cannot generate payload for unauthenticated create test.")
        # Check required FKs
        {% for field_name, field_details in create_payload_fields.items() %}
        {% if field_details.is_fk and not field_details.options.get('null', True) %}
        if '{{ field_name }}' not in payload:
            self.skipTest("Skipping unauth create: missing required FK '{{ field_name }}'.")
        {% endif %}
        {% endfor %}

        self.client.logout() # Ensure client is logged out
        response = self.client.post(list_url, payload, format='json')
        # Django returns 403 if SessionAuthentication fails, DRF TokenAuthentication returns 401
        self.assertIn(response.status_code, [status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN],
                      "Unauthenticated create should return 401 or 403")
    {% endif %}
